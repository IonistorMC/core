# IOnistor

**Ionistor** - это обёртка над TCP клиентом и сервером для удобного взаимодействия с протоколом Minecraft

## Наш RoadMap

- ✅ Полноценная реализация декодирования и кодирования протокола 1.13+
- ✅ Высокая производительность
- ✅ Отладка
- ✅ Чистый и поддерживаемый код
- ✅ Базовая реализация клиента
- ✅ Сжатие пакетов
- ⬜️ Реализация сервера
- ⬜️ Покрытие тестами более 75% кода

## Не входит в наши планы

- ❌ Реализация кодирования протокола 1.12 и ниже
- ❌ Полная реализация протокола
- ❌ Портирование сервера Minecraft на IOnistor
- ❌ Авторизация и шифрование

# FAQ

### Есть ли поддержка **Bedrock Edition**?

**Ionistor** - не реализация протокола, а лишь обёртка над низкоуровневой работой над сетью, поэтому вы можете его
использовать для взаимодействи как с **Java**, так и **Bedrock** версиями, однако **ionistor** пока не готов работать
с **Bedrock**, но это не мешает вам дополнить его прямо в своём проекте.

### Где взять готовые реализации пакетов?

Мы не сосредотачиваемся на конкретной реализации, а только максимально упрощаем процесс построения этой реализации,
чтобы не зависеть от версии и сохранять чистый и поддерживаемый код. Вы можете изучать пакеты с помощью **Ionistor**,
так и с помощью готовой статьи на https://wiki.vg

### Как сделать бота или мини сервер на **Ionistor**?

Всё ограничено вашей фантазией, с **Ionistor** вы только манипулируете пакетами, которые вы сами подготовили. Реализация
остаётся за вами. В наши планы входит создание подобных вещей, поэтому если вы владеете реализацией, то сможете помочь и
нам.

# Как использовать? Начнём быстро и сразу

Как только вы установили пакет в свой проект, вы уже можете начинать.

К примеру мы захотели сделать бота, который заходит на сервер и узнаёт время. Да, это бесполезный бот, но для примера
годится.

Начнём с построения пакета, зайдём на https://wiki.vg/Protocol и найдём интересующий нас пакет.

<table>
  <thead>
    <th>Packet ID</th>
    <th>State</th>
    <th>Bound To</th>
    <th>Field Name</th>
    <th>Field Type</th>
  </thead>
  <tbody>
    <tr>
      <td rowspan=2>0x59</td>
      <td rowspan=2>Play</td>
      <td rowspan=2>Client</td>
      <td>World Age</td>
      <td>Long</td>
    </tr>
    <tr>
      <td>Time of day</td>
      <td>Long</td>
    </tr>
  </tbody>
</table>

И так, это пакет типа `0x59` в состоянии `Play` - это означает, что мы ожидаем этот пакет, во время самой игры, когда
уже была пройдена авторизация. **Bound to client** - означает, что этот пакет отправляется с сервера на клиент. 

Интересует нас тут поле `Time of day` с типом `Long`
```ts
// импорты пропускаем, вашие IDE умные, чтобы сделать всё самостоятельно

// Указывем, что этот класс не просто пакет, а Пакет с типом 0x59 на состоянии Play
@Packet(0x59, PacketState.Play)
export class TimeUpdatePacket extends ProtocolPacket {
  // Лучше добавлять поля по порядку
  worldAge: long = 0 // long - просто переименнованный number, чтобы не забыть, что это long
  dayTime: long = 0 // Имена полей не имеют значения, т.к. не выходят за границы вашего проекта
  
  // Метод encode должен закодировать наш пакет,
  // мы не просто так расширяем пакет классом ProtocolPacket
  // он содержит готовые методы чтения/записи, для разных типов данных
  // Как при кодировании, так и декодировании пакетов, важно
  // соблюдать порядок полей
  encode() {
    this.writeLong(this.worldAge) // Записываем в пакет первое поле (worldAge)
    this.writeLong(this.dayTime) // И второе
    // Мы только что закодировали пакет
    // Подсказка: мы записали два поля с одинаковым типом подряд
    // поэтому мы можем объединить запись в один вызов
    // this.writeLong(this.worldAge, this.dayTime)
  }
  
  // Метод decode должен раскодировать пакет в том же порядке
  decode(){
    this.worldAge = this.readLong() // Читаем первое поле (worldAge)
    this.dayTime = this.readLong() // И второе (dayTime)
    // Важно: Если вы импользуете неправильный тип для чтения/записи
    // это может привести к повреждению данных и ошибкам
  }
}
```
Ну вот пакет готов, теперь его нужно применить, соберём нашего бота и запустим

```ts
// Создаём наш клиент
const client = new IonistorClient()
// И подключаем его к серверу
client.connect('localhost', 25565)
// Теперь нужно как-то сказать серверу, что сейчас зайдёт игрок
// Для этого есть пакет Handshake(https://wiki.vg/Protocol#Handshake)
// Его вы уже должны будете создать сами, как и все требуемые пакеты
client.on('connect', () => {
  const handshake = new HandshakePacket()
  handshake.address = 'localhost' // Имя хоста на котором запущен сервер
  handshake.port = 25565 // Порт сервера
  handshake.protocolVersion = 758 // Указываем с какой версии заходит клиент (1.18.2)
  handshake.nextState = PacketState.Play // Как только всё пройдёт успешно, сервер переведёт нас в режим игры
  // Таким образом мы указываем,
  // что мы подключаемся на сервер намеренно, а не случайно

  // Отправляем пакет
  client.send(handshake)
})
// Большинство серверов маинкрафт требуют сжимать пакеты
// при достижении определённой длины, чтобы экономить трафик,
// поэтому нам придётся отреагировать на этот пакет
// и включить сжатие
client.onPacket(SetCompressionPacket, ({ packet, enableCompression }) => {
  // В слушатель пакетов приходит уже декодированный пакет
  // нужно только извлечь из него данные
  enableCompression(packet.threshold)
})
// Ждём пакета, о том, что всё прошло успешно и мы вошли
client.onPacket(LoginSuccessPacket, ({ setState }) => {
  // Мы готовы принимать пакеты связанные с игровым процессом
  setState(PacketState.Play)
})
// Вот теперь самое интересное. Узнаём время. Тут то нам и понадобится главный пакет
client.onPacket(TimeUpdatePacket, async ({ packet }) => {
  // Как только сервер отправит пакет об изменении времени, это время тутже отобразится в консоли
  console.log(`Time: ${packet.dayTime}`)
})
// Примерно через 20 секунд сервер кикнет бота, но это уже совсем другая история (см. wiki.vg)
```
